     Пермский филиал федерального государственного автономного образовательного учреждения высшего образования 
«Национальный исследовательский университет 
«Высшая школа экономики»

     Факультет экономики, менеджмента и бизнес-информатики          
     Сидоров Арсений Алексеевич
     
     ПРОГРАММНАЯ РЕАЛИЗАЦИЯ АЛГОРИТМА СЖАТИЯ ДАННЫХ
     Курсовая работа
     
     студента образовательной программы «Программная инженерия»
     по направлению подготовки 09.03.04 Программная инженерия
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     Руководитель
к.ф.-м.н., доцент,
доцент кафедры информационных технологий в бизнесе
    ____________________
    Л. В. Шестакова
    
               Пермь, 2019 год
    
    Аннотация
     Программная реализация алгоритма сжатия данных
     Автор: Сидоров Арсений Алексеевич, студент первого курса образовательной программы «Программная инженерия».
     Руководитель: Шестакова Лидия Валентиновна, преподаватель кафедры информационных технологий в бизнесе.
     Данная курсовая работа посвящена разработке Windows приложения с реализацией алгоритма Хаффмана.
     Работа включает 55 страниц формата А4, из них 26 в основной части страниц.
     Основная часть работы включает в себя 12 иллюстраций и 6 таблиц.
     Библиографический список состоит из 7 публикаций.
     Работа включает в себя 8 приложений.
    
    
    
    
    
    
    
    
    
    


    Оглавление
     Введение	4
     Глава 1. Анализ предметной области	6
     1.1 Обзор существующих алгоритмов сжатия данных	6
     1.2	Алгоритм сжатия Хаффмана	8
     1.3. Требования к программному приложению	10
     Глава 2. Проектирование приложения	11
     2.1 Описание основных функций приложения	11
     2.2 Проектирование интерфейса	12
     2.3 Описание классов	13
     Глава 3. Реализация приложения	16
     3.1. Разработка приложения	16
     3.2. Интерфейс приложения	20
     3.3. Тестирование приложения	22
     3.3.1. Виды тестирования	22
     3.3.2. Итоги тестирования	23
     Заключение	25
     Библиографический список	27
     Приложение А.	Блок-схема функции алгоритма сжатия Хаффмана	28
     Приложение Б.	Получение текста из кода	30
     Приложение В.	Кодирование дерева	31
     Приложение Г.	Блок-схема функции получения дерева из кода	32
     Приложение Д.	Функция CombineMins()	33
     Приложение Е.	Интерфейс приложения	34
     Приложение Ж.	Листинг кода	39
     Приложение З.	Тесты	50

    Введение
     В наше время объем количества информации растет в геометрической прогрессии. С каждым днем создаются терабайты новой информации, которые необходимо передавать и хранить. Для того, чтобы эти процессы были более эффективными, были придуманы различные способы сжатия данных, в том числе алгоритм Шеннона – Фано. В связи с наличием несовершенств в данном алгоритме сжатия, на его был создан алгоритм Хаффмана, о котором и пойдет речь в этой работе.
     Почему алгоритм, придуманный несколько лет назад, актуален до сих пор? Во-первых, потому что методы хранения информации не изменились за десятилетия. Люди до сих пор используют двоичное представление информации. Во-вторых, не создано до сих пор такого простого и универсального алгоритма для сжатия данных. Без сомнений есть множество других, возможно более эффективных алгоритмов, но они либо работают для небольшого множества файлов, либо слишком сложны. Алгоритм Хаффмана является в данном случае сбалансированных решением.
     
     Объект исследования – алгоритмы сжатия данных. Предмет исследования – алгоритм сжатия Хаффмана.
     Данная работа полезна с теоретической точки зрения. Очень важно иметь представление об алгоритмах сжатия данных, в особенности об алгоритме Хаффмана. В работе также будет использована теория графов, которая применима в наши дни во многих сферах. Данные теоретические навыки могут пригодиться в будущих проектах. Разработав программную реализацию данного алгоритма, я получу навыки работы с языком программирования C#, интерфейсом разработки приложений Windows Forms.
     Целью работы является программная реализация алгоритма Хаффмана, с помощью интерфейса программирования приложений Windows Forms.
     Для достижения цели следует решить следующие задачи:
1. Провести анализ алгоритмов сжатия данных.
2. Сформулировать требования к приложению по реализации алгоритма Хаффмана. 
3. Выбрать структуры данных и алгоритмы работы с ними, необходимые для реализации алгоритма.
4. Спроектировать приложение.
5. Разработать приложение.
6. Протестировать приложение.
     
     
     
     
     

Глава 1. Анализ предметной области
     Целью анализа является обзор существующих алгоритмов сжатия и выбор оптимального варианта, который будет наиболее удобен и эффективен в реалиях поставленной задачи.
1.1 Обзор существующих алгоритмов сжатия данных
     Сейчас технологии развиваются очень стремительно. Было создано большое количество алгоритмов сжатия, однако самые оптимальные в плане скорости, сжатия и простоты были созданы еще в предыдущем столетии. 
     Все методы сжатия можно поделить на два больших класса. Одни алгоритмы только изменяют способ представления входных данных, приводя их к форме, которая более компактно кодируется. Такие алгоритмы называют обратимыми, поскольку для них существуют обратные алгоритмы, которые могут абсолютно точно восстановить исходные данные. Форматами, использующими подобный тип алгоритмов, являются GIF, PNG, AVI и так далее. Другие алгоритмы выделяют существенную часть, и ту, которой можно пренебречь для экономии памяти. Эти алгоритмы называют алгоритмы с регулируемой потерей информации. Один из самых известных форматов со сжатием с потерями является JPEG. В данной работе я буду рассматривать только обратимые алгоритмы сжатия. 
     Метод упаковки
     Суть метода упаковки заключается в уменьшении количества бит, отводимых для кодирования символов, если в сжимаемом массиве данных присутствует только небольшая часть используемого алфавита. Например, слово «молоко» занимает 6 байт. Оно содержит 4 различных символа, а для кодирования такого количества достаточно 2 бит, целого байта будет для этого много. Например, букву «м» заменяется на «01», «о» на «10», «к» на «00», а «л» на «11». В итоге получается строка «011011100010» – 12 бит [3]. 
     Однако этот метод имеет очевидный недостаток – при увеличении количества различных символов в строке размер сжатых данных может сильно возрасти. Если в строку «молоко» добавить символ «в», то сжатая строка будет уже занимать 21 бит – почти в два раза больше.
     Run-Length Encoding
     RLE имеет очень простой алгоритм сжатия, он заменяет последовательность из одинаковых символов на пару символ-количество. Такой алгоритм эффективно использовать при сжатии графических данных [2].
     Возьмем простое графическое изображение, состоящее из черного и белого цвета, например белый лист с текстом. В нём «b» обозначает черный цвет, а «w» – белый. Строка изображения выглядит следующим образом:

Рисунок 1.1. Пример исходной строки алгоритма RLE
     Если применить кодирование, получится следующая строка:

Рисунок 1.2. Пример сжатой строки алгоритма RLE
     Теперь строка состоит из 16 символов вместо 32. Очевидно, что данный алгоритм уместно применять только к данным, содержащим очень длинные последовательности одинаковых символов. Если изображение будет содержать плавный переход цвета, то алгоритм будет малоэффективен.
     Алгоритм Лемпеля – Зива – Велча
     В процессе кодирования с помощью этого алгоритма создается словарь фраз: определённым последовательностям символов, их еще называют фразами, ставятся в соответствие группы битов конкретной длины. Инициализация словаря происходит с помощью всех 1-символьных фраз (если символы 8-битные — это 256 фраз). По мере кодирования алгоритм просматривает последовательно все символы. При чтении алгоритмом очередного символа в данной позиции находится строка W максимальной длины, совпадающая с какой-то фразой из словаря. Затем код этой фразы подаётся на выход, а строка WK, где K — это символ, следующий за W во входном сообщении, вносится в словарь в качестве новой фразы и ей присваивается какой-то код (так как W выбрана жадно, WK ещё не содержится в словаре). Символ K играет роль начала следующей фразы. Алгоритм также имеет недостаток, он не проводит анализ входных данных, то есть ко всем входным строкам будет применен один и тот же алгоритм [1]. 
     
1.2  Алгоритм сжатия Хаффмана
     Метод алгоритма Хаффмана заключается в кодировании наиболее встречающихся символов самыми короткими битовыми последовательностями [3]. Кодирование по Хаффману происходит за два прохода. На первом проходе считываются частоты встречаемости всех символов. Затем по этим данным строится дерево кодирования Хаффмана, а по нему – коды символов. После этого данные читаются еще раз и при этом генерируется выходной массив данных. 
     Рассмотрим пример сжатия строки с использование алгоритма Хаффмана. Возьмем строку, содержащую как повторяющиеся символы, так и встречающиеся всего один раз. Например, «КОЛ_ОКОЛО_КОЛОКОЛА». В данной строке есть 5 различных символов, 4 буквы и нижняя черта. 
     Во-первых, нам надо подсчитать количество повторений каждого символа в данной строке. Получилось, что буква «Л» встречается 4 раза, «К» встречается также 4 раза, «О» – 7 раз, нижняя черта – 2 раза, а буква «А» всего один раз. 
     Во-вторых, построить бинарное дерево, узел которого будет иметь значение веса. Начинаем строить дерево с конечных узлов, вес которых равен соответственно количеству повторений символов в строке. Далее мы берем два узла с наименьшим весом и создаем из них новый узел, вес которого будет равен сумме двух весов потомков. Аналогично повторяем данное действе, пока все узлы не будут соединены в один. Вес последнего, корневого узла, должен быть равен количеству символов в строке. В итоге должно получиться подобное дерево (см. рис. 1.3).
     
      Рисунок 1.3. Бинарное дерево кодирования по алгоритму Хаффмана. 
     Однако оно может принимать и другие виды, так как если двух минимумов несколько, то выбрать можно любой, результат не станет хуже. Затем проходим по всему этому дереву, начиная с корневого элемента. Ставим ноль на ребре, если идем вверх, единицу – если вниз. Должно получиться следующим образом (см. рис. 1.4). 
     
Рисунок 1.4. Бинарное дерево для сжатия по Хаффману с размеченными рёбрами.
     Затем на основе полученного дерева идёт построение таблицы значений. Путь к каждой букве начинается с корневого элемента. Идем по ветвям к каждой букве, параллельно запоминая путь из нулей и единиц. Для удобства работы с деревом рекомендуется обходить его слева-направо. 
     Получив результаты, можно отметить, что буквы «О», «К» и «Л» имеют более короткий код, нежели остальные буквы. Так получилось как раз из-за частоты встречаемости этих символов.
     Полученная таблица: 
      Таблица 1. 1. Полученные коды для каждой буквы исходной строки
СимволКодО00К01Л10_110А111
     В итоге мы получаем строку «010010110000100100011001001000010010111». Её длина равна 39 битам. Исходный объем в кодировке ASCII 18*8=144 бита. Коэффициент сжатия равен 144/39 = 3,7. Для сравнения, если мы сожмём данную строку с помощью метода упаковки, то полученный объем сжатой строки будет 54 бита. Сжатие по RLE нет смысла проводить, так как исходная строка не содержит последовательности из одинаковых символов. 
     Чтобы получить обратно исходные данные из последовательности нулей и единиц, необходимо дерево, полученное при построении. Ставим маркер на корневой элемент. Затем посимвольно рассматриваем сжатую строку, если встретился ноль, маркер двигается по левому ребру, если единица, то по правому. Если встречаем конечный элемент, то пишем полученную букву и переставляем маркер снова на корневой элемент. Так повторяем, пока не дойдем до конца последовательности. 
     1.3. Требования к программному приложению
     Функциональные требования:
* ввод текста с клавиатуры;
* чтение текста из файла;
* вывод сжатого текста на экран в виде двоичного кода;
* вывод коэффициента сжатия;
* сохранение двоичного кода дерева и сжатого текста в файл;
* восстановление текста по двоичному коду;
* восстановление текста и дерева по двоичному коду.
     Нефункциональные требования: 
* приложение Windows Forms;
* язык программирования C#
Глава 2. Проектирование приложения
     В данной главе описан этап проектирования будущего приложения. Первый раздел посвящён разбору алгоритмов, которые необходимы для осуществления работы с текстом, бинарными деревьями и текстовыми файлами.
     2.1 Описание основных функций приложения
     Для дальнейшего формирования интерфейса программы и выбора необходимых алгоритмов, в первую очередь, важно определить, какой функционал программа должна предоставлять пользователю. Как уже было сказано, приложение должно иметь как практическую, так и теоретическую значимость. 
1. Получение сжатого кода
     Самой главной функцией будет являться получение сжатого кода с помощью алгоритма Хаффмана. По нажатию определенной кнопки должен появляться сжатый код и коэффициент сжатия. Блок-схему алгоритма см. в прил. А.
      Таблица 2. 1
Входные данныеФормат входных данныхВыходные данныеstr - исходная строка, которую надо преобразовать сжатый кодstring - последовательность симвлоловstring compressedString - двоичное представление сжатого кода2. Получение обратно текста из кода
     Функция получения исходного текста из сжатого кода. Сначала, если дерево для текста не составлено, например в том случае, когда файл кода открывается из файла, то составляем дерево из двоичного кода. Затем производим распаковку по Хаффману. Блок-схему алгоритма см. в прил. Б.
      Таблица 2. 2
Входные данныеФормат входных данныхВыходные данныеstr - строка со сжатым кодом, которую предстоит распаковатьstring - полследовательность символовstring decompressedText - полученная строка с текстом     
3. Кодирование дерева с помощью двоичного кода
     Дополнительная функция, с помощью которой можно получить в сжатом виде не только исходный текст, но и дерево. На вход подается дерево и строка, в которую будут записываться биты. Принцип кодирования дерева таков: рекурсивная функция проходит по всем ветвям дерева. Если функция уходит вглубь, то записывается единица. Если функция заканчивает обработку, то записывается ноль как знак того, что идет возвращение к корню дерева. Далее кодируются все символы, встречающиеся в строке в единственном экземпляре. Блок-схему алгоритма см. в прил. В.
      Таблица 2. 3
Входные данныеФормат входных данныхВыходные данныеNode tree - дерево для кодирования текстаNode - элемент бинарного дереваstirng stree - строка, содержащая двоичное представление дерева и всех символов4.  Получение дерева из двоичного кода
     Закодированное дерево состоит из двоичного кода, отображающего иерархию и коды символов в таблице windows-1251.
      Таблица 2. 4
Входные данныеФормат входных данныхВыходные данныеencodedStr - строка с кодомstring - последовательность символовtree - дерево кодирования Хаффмана     2.2 Проектирование интерфейса
     Интерфейс приложения должен содержать элементы управления, которые позволят продемонстрировать весь функционал программы. Так как программа не требует промежуточных вычислений и все элементы управления возможно разместить на одном экране, принято решение весь функционал разместить на одном окне. Конечно, такой метод реализации интерфейса может показаться неудобным, но такое решение самое оптимальное в плане скорости взаимодействия пользователя с программой.

Рисунок 2. 1. Шаблон пользовательского интерфейса программы
     В верхней части окна формы будет расположено меню, которое имеет кнопки для открытия текстовых файлов и кода. В данной панели управления также будут находиться функции сохранения. Большое поле слева – поле для ввода текста, в котором можно будет напечатать текст или открыть какой-то внешний файл, в таком случае весь текст будет вставлен в это поле. Справа расположено поле для отображения кода. Это поле отображает результаты сжатия текста в поле слева. Также оно предназначено для отображения текста, получаемого из файлов, то есть содержимое файла с двоичным кодом будет отображаться в поле справа. Под полем слева расположены две кнопки – «Получение кода Хаффмана» и «Получение кода Хаффмана вместе с деревом». По нажатию первой кнопки будет отображаться двоичное представление текста, а по нажатию второй – двоичное дерево, символы в двоичном виде и сжатый текст. Кнопка под полем справа преобразует код либо полученный после сжатия, либо после открытия файла обратно в текст.  
     2.3 Описание классов
     В данном разделе кратко описываются классы, которые будут использоваться в программе. Необходимо выполнить эту заготовку для оптимального распределения кода в программе. 
Класс Program.cs
     Этот класс отвечает за вызов формы Windows Forms. В дальнейшем этот класс меняться не будет, весь код будет писаться в других классах.
Класс Form.cs
     Данный класс отвечает за отображаемую часть приложения. В нем определяется взаимодействие между другими классами и интерфейсом программы. Функции, реализовывающие нажатие кнопок и изменение свойств элементов на форме также описаны в этом классе.
Класс Node.cs
     В классе реализована работа с бинарными деревьями. Экземпляр данного класса является элементом дерева, а дерево формируется из этих элементов, связанных друг с другом с помощью ссылок. Описано два конструктора, с входными параметрами и без для большей гибкости и удобства. Еще класс содержит нестатические и множество статических методов. К нестатическим методам относится нахождение концевых элементов дерева. Среди статических методов есть создание дерева из массива концевых элементов, назначение концевым элементам символы, а также создание нового элемента дерева на основе двух минимумов. Класс также имеет несколько вспомогательных методов, которые выполняют часть задач, описанных выше в этом абзаце.
Класс EncodingText.cs
     Все, что связано с кодированием, описано в этом классе. Два главных метода класса – это кодирование текста и кодирование дерева. В методе кодирования текста происходит непосредственно преобразование текста в двоичный код. Метод кодирования дерева отвечает за двоичное кодирование иерархии дерева и символов, встречающихся в строке ввода. Остальные методы данного класса являются вспомогательными. Также в классе описаны свойства дерева, двоичного представления дерева и словарь, где роль ключа выполняет символ, а роль значение – бинарное представление символа.
Класс DecodingText.cs
     Класс отвечает за декомпрессию всех двоичных данных. В классе имеется два главных метода, которые получают дерево и текст из двоичного кода соответственно. Функция декомпрессии дерева читает вводимый файл и сначала строит дерево, а затем считывает 8 бит сразу, преобразует их в символ и назначает конечным элементам эти символы. Функция, отвечающая за декомпрессию кода Хаффмана считывает последовательно считывает биты со строки и двигает маркер по дереву. Когда маркер встречает символ, функция записывает его в строку.
Класс DialogWindows.cs
     Класс отвечает за сохранение и загрузку внешних файлов, путем вызова диалоговых окон выбора пути. Он имеет всего два метода, сохранение и загрузка, которые взаимодействуют с файлами типа .bin и .txt. 
Глава 3. Реализация приложения
     В этой главе описывается реализация приложения, реализующего алгоритм сжатия Хаффмана. Будет описан порядок разработки приложения, его классы и методы. Далее описывается интерфейс приложения, взаимодействие элементов Windows формы с классами и методами, необходимыми для работы приложения. Затем будет описан порядок тестирования приложения по черному ящику.
     3.1. Разработка приложения
     Разработка приложения производится на интерфейсе программирования Windows Forms на языке программирования C#. Для удобства читаемости и расширяемости программы, она поделена на несколько классов, каждый из которых выполняет определенную роль. 
Реализация класса Form.cs
     В классе описаны две функции: EncodedButtons() и DecodedButtons(). Они выполняют роль включения и выключения кнопок, в зависимости от ситуации. Например, функция EncodedButtons() вызывается, когда произведена кодировка и отображается только бинарный код. В этом случае окно с текстом станет пустым, а значит сохранение текста не будет иметь смысла. Функция блокирует эту возможность.
     Далее в классе реализована функция encodeBtn_Click(), которая отвечает за нажатие кнопки получения двоичного кода.

Рисунок 3.1. Функция encodeBtn_Click()
     В первой строчке блока try [4] идет вызов функции кодирования строки и возвращение результата в поле compressedTextBox.Text. Затем идет получение дерева, которое понадобится для дальнейшей работы. Обработчик может поймать только одно исключение, описанное в функции EncodingText.EncodeHuffman() вручную. Это исключение появляется, если на вход подана пустая строка. Далее в функции идет подсчет коэффициента сжатия в кодировке windows1251. Он будет выведен в элементе label. 
     Функция encodeWithTreeBtn_Click() работает аналогичным образом за исключением того, что помимо текста также кодируется дерево.
     Функции SaveTextBtn_Click() и  SaveCodeBtn_Click() – вызываются по нажатию кнопок сохранения текста и кода соответственно. В функциях прописано условие, предотвращающее от сохранения пустой строки.
     openText_Click() – функция, отвечающая за нажатие кнопки открытия внешнего текстового файла. Она вызывает DialogWindows.Load(), которая возвращает текст из файла. Однако, файл мог иметь неправильную кодировку или содержать символы, не реализованные в кодировке приложения. Идет проверка на соответствие длин исходного текста и байтовой последовательности, в которую преобразован текст. Если длины совпадают, то кодировка правильная. 

Рисунок 3.2. Функция OpenText-Click()
     openCode_Click() вызывается по нажатию кнопки открытия кода. Формат файла, хранящего код для удобства сделан .bin. При открытии файла может возникнуть проблема наличия лишних символов, то есть помимо 1 и 0 в строке могут быть другие. Однако функция допускает ввод перевода строки в коде. В работе данной функции прописан цикл, проходящий по каждому символу введенной битовой последовательности и если символ не равен 1, 0 или переводу строки, то вызывается сообщение об ошибке. Стоит отметить, что в конце функция удаляет все символы перевода строки, чтобы в дальнейшем работа с кодом была корректна. 

Рисунок 3.3. Функция SaveTextBtn_Click()
Реализация класса Node.cs
     Класс является описанием узла бинарного дерева, поэтому в нем описаны конструкторы Node(Node left=null, Node right=null, char? symbol = null) и (int weight, char? symbol = null). Первый конструктор предназначен для объединения двух узлов в один, а второй используется при создании массива конечных элементов дерева. Стоит отметить использование типа char?, который отличается от простого символьного типа тем, что может принимать значение null. Также в классе есть статическая функция MakeTreeFromEnds(), которая находит количество концевых элементов в дереве. Самой большой и сложной является функция CombineMins() (см. Приложение Д.), которая находит сначала первый минимум, а потом второй, затем удаляет минимумы и создает новый узел. 

Рисунок 3.4. Функция Save()
Реализация класса DialogWindows.cs
     Класс является вспомогательным, он выделяет работу с внешними файлами. В нем есть статическая функция Load(bool binary = false), которая принимает на вход булеву переменную binary. Если значение binary является истинным, то в диалоговом окне будут отображаться только файлы .bin, иначе только .txt. В функции есть условие: если диалоговое окно закрывается пользователем, то появляется исключение. Далее считывается весь текст из открываемого файла с форматом windows1251.Статическая функция Save(string s, binary = false) отвечает за сохранение файла. Алгоритм функции аналогичен функции Load(), но в конце записывает файл в директорию, вместо считывания. 
Реализация класса EncodingText.cs
     Класс отвечает за сжатие данных и состоит из двух главных функций: EncodeHuffman() и EncodeTree(), которые отвечают за кодирование текста и дерева соответственно. Функция кодирования дерева имеет в начале алгоритма проверку строки на пустоту, если строка пуста, появляется исключение. Далее создается словарь частоты встречаемости символов в строке с помощью вспомогательной функции MakeList(). Затем создается массив узлов на основе этого словаря с помощью функции GetNodeList(). Потом идет создание бинарного дерева. Его значение записывается в переменной с уровнем доступа public, так как она используется за пределами класса. Далее с помощью функции AssignBin() получается двоичное представление каждого символа. На выход подается сжатая строка. Функция EncodeTree() в начале работы вызывает функцию Run(), которая создает иерархию дерева. Затем кодируются все символы. Сначала они преобразуются в массив байтов, а потом в массив битов. Функция возвращает строку с единицами и нулями. 

Рисунок 3.5. Функция EncodeHuffman()
Реализация класса DecodingText.cs
     Декомпрессия строки происходит с помощью класса декодирования, в котором находится функция DecodeHuffman(). На вход функции подается дерево и двоичная строка. Алгоритм нахождения исходного текста аналогичен описанному в Главе 1. За декодирование дерева отвечает функция DecodeTree(). Она вызывает рекурсивную функцию Run(), в которой просматривается иерархия дерева. Затем функция находит количество концевых элементов полученного дерева, так она узнает, сколько раз надо считывать со строки закодированные символы. Декодирование символов происходит в цикле foreach, в котором образуется массив байтов. Из него мы получаем строку с символами. Далее вызывается функция AttachSymbols, находящаяся в классе Node, с помощью которой мы записываем в конечные элементы дерева полученные символы.
     3.2. Интерфейс приложения
     При запуске приложения отрывается основное окно для работы с данными. Название окна – Алгорим Хаффмана. В верхней части находится меню, которое содержит пункты «Очистить» и «Файл», который в свою очередь имеет подпункты «Открыть» и «Сохранить». Панель управления окном содержит стандартные элементы: закрытия окна, сворачивания окна, кнопка расширения окна является недоступной. Левую часть приложения занимает текстовое поле, в которое может быть введён текст, подлежащий дальнейшей кодировке. Ниже поля для ввода располагаются кнопки «Получить сжатый код» и «Получить дерево с кодом», обе кнопки являются активными. На правой половине окна находится поле, предназначенное для отображения кода. Поле является неактивным, то есть его редактирование невозможно. Ближе к нижнему краю окна имеется кнопка «Получить текст из кода», которая пока также неактивна (рис. 3.6).  На данном этапе пользователь может осуществить несколько действий: ввести текст в поле, открыть код или текст из файла.

Рисунок 3.6.  Начальный вид окна
     После ввода строки в текстовое поле (Приложение Е, рис. 1) и нажатия на кнопку «Получить сжатый код», в правом поле появляется код сжатой строки, а также надпись, которая говорит о том, какой коэффициент сжатия (Приложение Е, рис. 2). Становится активной кнопка «Получить текст из кода», при нажатии на которую в левом окне вновь отображается набранный ранее текст. В меню становится доступной функция сохранения кода, функция сохранения текста, наоборот, недоступна. Аналогично изменяются свойства элементов управления, в частности кнопок и пунктов меню, при выборе «Получить дерево с кодом» (Приложение Е, рис. 3). Отличие заключается в коде, коэффициент сжатия остаётся прежним.
     При выборе пункта меню «Сохранить код» открывается стандартное диалоговое окно сохранения. Пользователю предлагают сохранить код в формате .bin (Приложение Е, рис. 4). При сохранении текста файл имеет расширение .txt (Приложение Е, рис. 5).
     При выборе опции «Открыть текст» вызывается диалоговое окно выбора файла. Принимаются только файлы формата txt (Приложение Е, рис. 6). Текст из файла заносится в правое поле (Приложение Е, рис. 7) и в последствие может быть сжат. Пользователь также может при помощи диалогового окна открыть код из файла, который имеет расширение bin (Приложение Е, рис. 8). Код отображается в правом поле; имеется возможность декодирования. Программа может осуществить декодирование как обычного кода, так и дерева. Если текст превышает размеры поля, появляется колесо прокрутки (Приложение Е, рис. 9). Если файл кода содержит недопустимые элементы пользователь видит предупреждающие сообщение (см. рис. 3.7). Кнопки открытия файла всегда доступны. 
     При нажатии на кнопку «Очистить» опустошаются обо поля, форма принимает начальный вид. Пользователь может выполнить все доступные действия.

Рисунок 3.7.  Предупреждающие сообщение
     3.3. Тестирование приложения
     Тестирование – процесс, позволяющий проверить программу на наличие ошибок. В данном разделе будет описание некоторых существующих на данный момент способов тестирования программы. Будут рассмотрены принципы работы, преимущества и недостатки всех способов. В конце будет проведено тестирование приложения по одному из способов.
3.3.1. Виды тестирования
     Тестирование программы является важным процессом в ходе разработки, поэтому ему уделяется много внимания и до, и после создания программы. Тестировать можно сразу несколькими способами для еще большего улучшения качества программы. 
     Модульное тестирование
     Модульное тестирование проверяет отдельные части программы или модули исходного кода [6]. Идея состоит том, что идет проверка большинства функций программы, путем сравнивания ожидаемого и полученного результата выполнения. Такой способ тестирования может легко выявить функцию, выдающую неправильный ответ, и поэтому исправление ошибки не будет слишком проблематичным. У модульного тестирования есть также недостатки. Если результатов работы функции может быть несколько при одних и тех же входных данных или ответ может быть получен только приблизительно, то определить корректность работы программы очень сложно. 
     В разрабатываемой программе не будет использоваться такой метод тестирования вследствие ненадежности способа. 
     Тестирование по белому ящику
     Такой метод тестирования предполагает, что тестировщик знает внутреннее устройство программы [7]. Суть метода заключается в обходе всех возможных вариантов работы программы. Данный способ тестирования можно считать довольно надежным, ведь рассматриваются не отдельные части программного кода, а алгоритм поведения программы целиком. Проверка программы данным способом не будет производиться, так как данный метод тестирования потребует очень много времени для проведения. Чем больше программа, тем больше различных путей она имеет, в следствие обработать каждый возможный алгоритм очень сложно.
     Тестирование по черному ящику
     Тестирование по черному ящику отличается от тестирования по белому тем, что тестировщик может не ведать, как работает программа [5]. У черного ящика существуют несколько критериев:
1. тестирование функций программы;
2. тестирование длины набора данных;
3. тестирование классов входных данных;
4. тестирование классов выходных данных;
5. тестирование ОДЗ
     Наличие нескольких критериев однозначно является признаком надежности метода тестирования. Именно этот способ был выбран в качестве метода тестирования программы, потому что он наиболее оптимальный в плане качества и затратности времени на фоне размера созданной программы. Стоит отметить, что будь программа меньше или больше в объёме, вероятно был бы выбран другой способ тестирования. Таблица с наборами тестов и черным ящиком находятся в приложении З. 
3.3.2. Итоги тестирования
     После проведения тестирования было выявлено 4 ошибки:
– программа открывала некорректно закодированные файлы
– программа ошибочно кодировала символы неправильной кодировки
– поле для ввода текста позволяло вставлять из буфера обмена картинки и прочие файлы
– окно программы можно было изменять в размерах 
     Все вышеперечисленные ошибки были успешно исправлены, путем добавления обработчиков или изменения существующего кода. 
    Заключение
     По окончании создания приложения мной выполнены все поставленные задачи. Приложение получилось соответствующим ожиданиям, оно выполняет все функции, которые было необходимо реализовать.
     Результаты выполнения работы:
– сформулированы требования к приложению.
– спроектирован макет приложения.
– разработан шаблон дизайна.
– реализовано приложение windows forms для сжатия текста с помощью алгоритма Хаффмана.
– проанализированы возможные способы тестирования программы и выбор оптимального варианта – черный ящик.
     В процессе работы над приложением было получено множество практических навыков, применимых в будущем, а именно:
1. Навык разработки в Windows Forms
     Половина процесса разработки заняло создание пользовательского интерфейса в Windows Forms API. Работу с ним можно назвать удобной и практичной. Получены навыки взаимодействия интерфейса и внутренних процессов приложения.
2. Навык работы с алгоритмом сжатия данных
     В процессе анализа было рассмотрено множество алгоритмов сжатия данных, каждый из которых используется и в наши дни, какой-то в большей, а какой-то в меньшей степени. Алгоритм Хаффмана является удобным и простым в освоении методом сжатия, который можно использовать в будущих проектах.
3. Навык работы с деревьями
     Работа с деревьями заняла огромную долю затраченного времени, но результаты оправдали ожидания. Деревья использовались в кодировании алгоритма Хаффмана, как инструмент компрессии и декомпрессии. В кодировании самого дерева помогла теория графов.
4. Навык разработки с помощью языка программирования C#
     Опыт разработки на объектно-ориентированном языке полезен в наши дни, так как используемая парадигма самая распространенная. Был получен опыт работы с объектами, классами и их взаимодействием.
5. Навык работы с файлами
     Реализация работы с вводом и выводом текста из файла являлась одной из самых главных задач. Такой метод работы с различными данными очень удобный и практичный. 
    Библиографический список
1. Алгоритм LZW // sernam.ru URL: http://sernam.ru/cod_5.php (дата обращения: 10.03.2019).
2. Алгоритм RLE // sernam.ru URL: http://sernam.ru/cod_4.php (дата обращения: 10.03.2019).
3. Андреева Е. В. Математические основы информатики. Элективный курс: Учебное пособие / Е. В. Андреева, Л. Л. Босова, И. Н. Фалина – 2-е изд., испр. – М.: БИНОМ. Лаборатория знаний, 2007. – 328 с.: ил.
4. Обработка исключений в Си-шарп. Оператор try-catch // mycsharp.ru URL: http://mycsharp.ru/post/18/2013_06_10_obrabotka_isklyuchenij_v_si-sharp_operator_try-catch.html (дата обращения: 7.03.2019).
5. Плаксин. М. А. Тестирование и отладка программ – для профессионалов будущих и настоящих / М. А. Плаксин. –М.: БИНОМ. Лаборатория знаний, 2007. – 167 с.: ил.
6. Модульное тестирование // qalight.com.ua URL: https://qalight.com.ua/baza-znaniy/modulnoe-testirovanie/ (дата обращения: 4.03.2019).
7. White/Black/Grey Box-тестирование // qalight.com.ua      
URL: https://qalight.com.ua/baza-znaniy/modulnoe-testirovanie/ (дата обращения: 24.03.2019).

8. 

Приложение А.  Блок-схема функции алгоритма сжатия Хаффмана


Рисунок 1. Блок-схема функции алгоритма сжатия Хаффмана (1 часть)


Рисунок 2. Блок-схема функции получения алгоритма Хаффмана (2 часть)
Приложение Б.  Получение текста из кода

Рисунок 1. Блок-схема функции получения текста из кода
Приложение В.  Кодирование дерева

Рисунок 1. Блок-схема функции получения дерева
Приложение Г.  Блок-схема функции получения дерева из кода

Рисунок 1. Блок-схема функции получения дерева из кода
Приложение Д.  Функция CombineMins()

Рисунок 1. Функция CombineMins()


Приложение Е.  Интерфейс приложения
        

      Рисунок 1. Заполненное текстовое поле

      Рисунок 2. Сжатый код строки

      Рисунок 3.  Дерево с кодом

      Рисунок 4. Сохранение кода

      Рисунок 5. Сохранение текста

      Рисунок 6. Открытие текста

      Рисунок 7. Текст из файла

      Рисунок 8. Открытие кода

      Рисунок 9.  Код из файла
Приложение Ж.  Листинг кода
     Класс Form.cs
using System;
using System.Text;
using System.Windows.Forms;

namespace HuffmanRealization
{
    public partial class Form : System.Windows.Forms.Form
    {
        public static bool encodedStrWithTree;// Булево поле, отвечающее за споссоб кодировки текста (с деревом или без него)
        public static bool encoded; // Закодирован ли текст в данный момент
        public Form()
        {
            InitializeComponent();
            DecodedButtons();
        }

        //Функция, устанавливающая активность кнопок на форме, если текст закодирован
        private void EncodedButtons()
        {
            encodeTreeBtn.Enabled = false;
            encodeBtn.Enabled = false;
            decodeBtn.Enabled = true;
            SaveCodeBtn.Enabled = true;
            SaveTextBtn.Enabled = false;
            encoded = true;
        }
        // Функция, устанавливающая активность кнопок на форме, если текст не закодирован
        private void DecodedButtons()
        {
            decodeBtn.Enabled = false;
            encodeBtn.Enabled = true;
            encodeTreeBtn.Enabled = true;
            SaveTextBtn.Enabled = true;
            SaveCodeBtn.Enabled = false;
            encoded = false;
        }

        // Код функции нажатия кнопки кодировки без дерева
        private void encodeBtn_Click(object sender, EventArgs e)
        {
            try
            {
                compressedTextBox.Text = EncodingText.EncodeHuffman(textBox.Text); // Получение сжатого кода
                EncodingText.RootCode = EncodingText.EncodeTree(EncodingText.Root); // Получение дерева
            }
            catch (Exception) // Если поймано исключение, выйти из функции
            {
                MessageBox.Show("Введите текст");
                return;
            }
            double cooficient = textBox.Text.Length * 8 / (double)compressedTextBox.Text.Length; // Подсчет коэффициента
            
            textBox.Text = "";
            encodedStrWithTree = false; 
            EncodedButtons();

            label2.Text = "Коэффициент сжатия - " + string.Format("{0:N2}", cooficient); // Отображение коэффициента сжатия на label

        }

        private void button2_Click_1(object sender, EventArgs e)
        {
            string back = compressedTextBox.Text;
            Node root = new Node();
            string decompressedText = "";

            try
            {
                // Если строка была закодирована вместе с деревом, то сначала надо декодировать дерево
                if (encodedStrWithTree)
                {
                    root = DecodingText.DecodeTree(ref back);
                }
                //Иначе оно хранится в классе EncodingText в поле Root
                else
                {
                    root = EncodingText.Root;
                }
                decompressedText = DecodingText.DecodeHuffman(root, back); // Декодирование двоичного кода
                textBox.Text = decompressedText;
            }
            catch (Exception) // Если не удается корректно преобразовать данные, выдать исключение
            {
                MessageBox.Show("Невозможно прочитать код. Откройте корректный файл");
            }
            compressedTextBox.Text = "";
            label2.Text = "";
            DecodedButtons();
        }


        // Очистить поля и привести все кнопки в положение "не закодировано"
        private void ClearToolStripMenuItem_Click(object sender, EventArgs e)
        {
            compressedTextBox.Text = "";
            textBox.Text = "";
            encodeBtn.Enabled = true;
            encodeTreeBtn.Enabled = true;
            decodeBtn.Enabled = false;
        }

        // Кодирование текста с деревом
        private void encodeWithTreeBtn_Click(object sender, EventArgs e)
        {
            string encodedStr = ""; // Заготовка для закодированной строки
            try
            {
                encodedStr = EncodingText.EncodeHuffman(textBox.Text); // Кодирование текста
                EncodingText.RootCode = EncodingText.EncodeTree(EncodingText.Root); // Кодирование дерева
                compressedTextBox.Text = EncodingText.RootCode + encodedStr; // Складываение строк и вывод в форму
            }
            catch (Exception) // Если поймано исключение, выйти из функции
            {
                MessageBox.Show("Введите текст");
                return;
            }
            double cooficient = textBox.Text.Length * 8 / (double)encodedStr.Length; // Подсчет коэффициента
            label2.Text = "Коэффициент сжатия - " + string.Format("{0:N2}", cooficient); // Вывод коэффициента

            encodedStrWithTree = true;
            textBox.Text = "";
            EncodedButtons();
        }

        // Сохранение
        private void SaveTextBtn_Click(object sender, EventArgs e)
        {
            if(textBox.Text == "")
            {
                MessageBox.Show("Введите текст");
                return;
            }
            DialogWindows.Save(textBox.Text);
        }

        // Открытие
        private void SaveCodeBtn_Click(object sender, EventArgs e)
        {
            if (compressedTextBox.Text == "")
            {
                MessageBox.Show("Введите текст");
                return;
            }
            DialogWindows.Save(encodedStrWithTree?compressedTextBox.Text: EncodingText.RootCode + compressedTextBox.Text, true);

        }

        private void OpenText_Click(object sender, EventArgs e)
        {
            try
            {
                textBox.Text = DialogWindows.Load(); // Загрузка текста из файла
            }
            catch (Exception)
            {
                return;
            }

            // Проверка на корректность кодировки
            if (!(Encoding.GetEncoding(1251).GetByteCount(textBox.Text) == textBox.Text.Length))
            {
                MessageBox.Show("Неверная кодировка. Откройте другой файл.");
                textBox.Text = "";
                return;
            }
            DecodedButtons();
            compressedTextBox.Text = "";
        }

        private void OpenCode_Click(object sender, EventArgs e)
        {
            try
            {
                compressedTextBox.Text = DialogWindows.Load(true); // Загрузка кода из файла
            }
            catch (Exception)
            {
                return;
            }

            // Проверка на наличие символов, помимо 1, 0 и перевода строки
            foreach (char c in compressedTextBox.Text)
            {
                if (!(c == '1' || c == '0' || c == Environment.NewLine[0] || c == Environment.NewLine[1]))
                {
                    MessageBox.Show("Строка содержит символы, помимо 1 или 0");
                    ClearToolStripMenuItem_Click(sender, e);
                    return;
                }
            }

            compressedTextBox.Text = compressedTextBox.Text.Replace("\n", string.Empty); // Удаление символов перевода строки
            EncodedButtons();
            encodedStrWithTree = true;
            textBox.Text = "";
        }

        private void textBox_KeyDown(object sender, KeyEventArgs e)
        {
            if( e.Control && e.KeyCode == Keys.V &&!Clipboard.ContainsText())
            {
                Clipboard.Clear();
            }
        }
    }
}
     Класс Node.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace HuffmanRealization
{
    // Класс бинарного дерева
    public class Node
    {
        public char? Symbol { get; set; } // Свойство символа (может равняться null)
        public Node LeftNode { get; set; } // Свойство левого поддерева
        public Node RightNode { get; set; } // Свойство правого поддерева
        private int weight; // Свойства веса узла
        public int Weight
        {
            get
            {
                return weight;
            }
            set
            {
                if (value < 0) Weight = 0; else weight = value;
            }
        }

        public Node(int weight, char? symbol = null)
        {
            Weight = weight;
            Symbol = symbol;
        }
        public Node(Node left=null, Node right=null, char? symbol = null)
        {
            LeftNode = left;
            RightNode = right;
            // Назначение веса узлу, если у него есть поддеревья, то назначить вес, равный сумме весов поддеревьев
            Weight = (left != null ? left.Weight : 0) + (right != null ? right.Weight : 0);
            Symbol = symbol;


        }

        // Нахождение количества конечных узлов
        public int FindNumberOfEnds()
        {
            int number = 0;
            RunningNumber(ref number, this);
            return number;
        }
        private void RunningNumber(ref int i, Node node)
        {
            if(node.LeftNode != null)
            {
                RunningNumber(ref i, node.LeftNode);
            }
            if (node.RightNode != null)
            {
                RunningNumber(ref i, node.RightNode);
            }
            if(node.RightNode == null && node.LeftNode == null)
            {
                i++;
            }
        }

        //Создание дерева из конечных узлов
        public static Node MakeTreeFromEnds(List<Node> nodes)
        {
            while (nodes.Count > 1)
            {
                CombineMins(nodes);
            }
            return nodes.First();
        }

        // Назначение символов конечным узлам дерева
        public static void AttachSymbols(Node node, ref string s)
        {
            if(node.LeftNode != null)
            {
                AttachSymbols(node.LeftNode, ref s);
            }
            if(node.RightNode != null)
            {
                AttachSymbols(node.RightNode, ref s);
            }
            if(node.RightNode == null && node.LeftNode == null)
            {
                node.Symbol = s[0];
                s = s.Substring(1);
            }
        }
        

        public static void CombineMins(List<Node> nodes)
        {
            Node min = new Node();
            Node min2 = new Node();
            int pos;
            int pos2;
            if (nodes[0].Weight < nodes[1].Weight)
            {
                min = nodes[0];
                min2 = nodes[1];
                pos = 0;
                pos2 = 1;
            }
            else
            {
                min = nodes[1];
                min2 = nodes[0];
                pos = 1;
                pos2 = 0;
            }
            
            // Нахождение первого минимума
            for(int i = 0; i < nodes.Count; i++)
            {
                if (nodes[i].Weight < min.Weight)
                {
                    min = nodes[i];
                    pos = i;

                }
            }
            
            // Нахождение второго минимума
            for (int i = 0; i < nodes.Count; i++)
            {
                if (nodes[i].Weight < min2.Weight && i != pos)
                {
                    min2 = nodes[i];
                    pos2 = i;

                }
            }

            nodes.Remove(min);
            nodes.Remove(min2);
            nodes.Add(new Node(min, min2));
        }
        
    }
}
     Класс EncodingText.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace HuffmanRealization
{
    public class EncodingText
    {
        public static Node Root { get; private set; } // Свойство дерева
        public static string RootCode { get; set; } // Свойство двоичного кода дерева 
        public static Dictionary<char?, string> BinaryStr { get; set; } // Словарь символ - двоичный код

        // Назначение символам двоичное представление в свойстве BinaryStr
        private static Dictionary<char?, string> AssignBinWrapper(Node root, string n)
        {
            BinaryStr = new Dictionary<char?, string>();
            AssignBytes(root, n, BinaryStr);
            return BinaryStr;
        }

        private static void AssignBytes(Node node, string n, Dictionary<char?, string> bytesStr)
        {
            if (node.LeftNode != null)
                AssignBytes(node.LeftNode, n + "0", bytesStr);

            if (node.RightNode != null)
                AssignBytes(node.RightNode, n + "1", bytesStr);

            if (node.LeftNode == null && node.RightNode == null)
            {
                bytesStr.Add(node.Symbol, n);
            }
        }

        //Создание словаря из исходной строки
        private static List<KeyValuePair<char, int>> MakeList(string str)
        {
            Dictionary<char, int> dict = new Dictionary<char, int>();
            foreach (char c in str)
            {
                //Если словарь не содержит символ
                //Добавить его со значением 1
                if (!dict.ContainsKey(c))
                    dict.Add(c, 1);
                //Иначе прибавить к значению 1
                else
                    dict[c]++;
            }
            //Получить список из словаря
            return dict.ToList();

        }

        //Получение списка из узлов на основе массива пар ключ - значение
        private static List<Node> GetNodeList(List<KeyValuePair<char, int>> dictList)
        {
            List<Node> nodeList = new List<Node>();

            foreach (KeyValuePair<char, int> pair in dictList)
            {
                nodeList.Add(new Node(pair.Value, pair.Key));
            }
            return nodeList;
        }

        // Формирование итоговой строки на вывод
        private static string MakeCompressedString(string str, Dictionary<char?, string> bytesStr)
        {
            string compressedStr = "";
            foreach(char c in str)
            {
                compressedStr += bytesStr[c];
            }
            return compressedStr;
        }

        // Функция кодирования по Хаффману
        public static string EncodeHuffman(string str)
        {
            //Если строка пустая, бросить исключение
            if(str == "")
            {
                throw new Exception();
            }

            // Создание словаря
            List<KeyValuePair<char, int>> dictionaryList = MakeList(str);

            //Создание массива узлов
            List<Node> nodeList = GetNodeList(dictionaryList);

            //Создание дерева
            Root = Node.MakeTreeFromEnds(nodeList);

            //Назначение символам их двоичные коды
            Dictionary<char?, string> binaryStr = AssignBinWrapper(Root, dictionaryList.Count == 1 ? "0" : "");

            // Возвращение полученной строки
            return MakeCompressedString(str, binaryStr);
        }

        // Кодирование дерева
        public static string EncodeTree(Node node)
        {
            string s = "";
            Run(node, ref s);
            foreach (char c in BinaryStr.Keys)
            {
                var bytes = Encoding.GetEncoding(1251).GetBytes(c.ToString());
                var binstr = string.Join("", bytes.Select(b => Convert.ToString(b, 2)));
                s += string.Format("{0:d8}", int.Parse(binstr));

            }
            return s;

        }

        //Создание двоичного представления по принципу:
        //Если отдаляемся от корня, то пишем 1
        //Если приближаемся, пишем 0
        private static void Run(Node node, ref string s)
        {
            if (node.LeftNode != null)
            {
                s += "1";
                Run(node.LeftNode, ref s);
            }
            if (node.RightNode != null)
            {
                s += "1";
                Run(node.RightNode, ref s);

            }
            s += "0";

        }
    }
}
     Класс DecodingText.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace HuffmanRealization
{
    public class DecodingText
    {
        // Функция декодирования строки
        public static string DecodeHuffman(Node tree, string binaryCode)
        {
            Node pointer = tree; //Маркер для перемещения по дереву
            string decompressedText = ""; //Строка на вывод
            foreach (char c in binaryCode)
            {
                
                //Если символ строки равен 0, перейти в левое поддерево
                if (c == '0' && pointer.LeftNode !=null)
                    pointer = pointer.LeftNode;
                //Иначе в правое поддерево
                else if (c == '1' && pointer.RightNode!=null)
                    pointer = pointer.RightNode;
                //Если в узле есть символ, то добавить его в строку на вывод
                if (pointer.Symbol != null)
                {
                    decompressedText += pointer.Symbol;
                    pointer = tree;
                }

            }
            return decompressedText;
        }

        // Функция декодирования дерева
        public static Node DecodeTree(ref string s)
        {
            Node tree = new Node();
            Run(tree, ref s); // Вызов вспомогательной функции Run

            int number = tree.FindNumberOfEnds(); // Нахождение количества конечных элементов дерева

            List<byte> byteList = new List<byte>();

            for (int i = 0; i < number; i++)
            {
                byteList.Add(Convert.ToByte(s.Substring(0, 8), 2)); // Добавление в массив байтов Строку из 8 битов, преобразованную в байт
                s = s.Substring(8); // Удаление первых восьми символов из строки
            }
            string symbols = Encoding.GetEncoding(1251).GetString(byteList.ToArray()); // Преобразование массива байтов в текстовую строку
            Node.AttachSymbols(tree, ref symbols); // Назначить конечным элементам символы
            return tree;
        }
        private static void Run(Node ptr, ref string s)
        {
            // Если первый символ равен 1, то создать левое поддерево и перейти в него
            if (s[0] == '1')
            {
                ptr.LeftNode = new Node();
                s = s.Substring(1, s.Length-1); // Удаление первого символа
                Run(ptr.LeftNode, ref s);
            }
            // Если первый символ равен 1, то создать левое поддерево и перейти в него
            if (s[0] == '1')
            {
                ptr.RightNode = new Node();
                s = s.Substring(1, s.Length-1); // Удаление первого символа
                Run(ptr.RightNode, ref s);

            }
            s = s.Substring(1, s.Length-1); // Удаление первого символа
        }
    }
}
     Класс DialogWindows.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace HuffmanRealization
{
    //Класс, отвечающий за сохраниение и открытие файлов
    public class DialogWindows
    {
        //Сохранение файлов
        public static void Save(string s, bool binary = false)//Если binary == true, то файл сохраняется в формате .bin (по умолчанию binary = false)
        {
            SaveFileDialog dialog = new SaveFileDialog();
            if(binary)
                dialog.Filter = "bin files (*.bin)|*.bin";
            else
                dialog.Filter = "txt files (*.txt)|*.txt";
            //Если диалогове окно закрывается, функция бросает исключение
            if (dialog.ShowDialog() == DialogResult.Cancel)
                return;
            //Запись файла в кодировке windows-1251
            File.WriteAllText(dialog.FileName, s, Encoding.GetEncoding(1251));

        }


        public static string Load(bool binary = false)//Если binary == true, то файлы отображаются в формате .bin (по умолчанию binary = false)
        {
            OpenFileDialog dialog = new OpenFileDialog();
            if (binary)
                dialog.Filter = "bin files (*.bin)|*.bin";
            else
                dialog.Filter = "txt files (*.txt)|*.txt";
            //Если диалогове окно закрывается, функция бросает исключение
            if (dialog.ShowDialog() == DialogResult.Cancel)
            {
                throw new Exception();
            }
            //Считывание текста в кодировке windows-1251
            return File.ReadAllText(dialog.FileName, Encoding.GetEncoding(1251));
        }
    }
}
     Класс Program.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace HuffmanRealization
{
    static class Program
    {
        /// <summary>
        /// Главная точка входа для приложения.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form()); // Вызов формы
        }
    }
}
Приложение З.  Тесты
      Таблица 1. Тесты программы
Номер тестаВходные данные Ожидаемый результатРеальный результат1Ввод "abc", сжатие без дереваПоявление во втором окне кода 11100Появление во втором окне кода 111002Ввод "абв", сжатие без дереваПоявление во втором окне кода 11100Появление во втором окне кода 111003Ввод "101", сжатие без дереваПоявление во втором окне кода 101Появление во втором окне кода 1014Ввод "abc101абв", сжатие без дереваПоявление во втором окне кода 011010000111001111100101110Появление во втором окне кода 0110100001110011111001011105Ввод "abc", сжатие с деревом10110100001100011011000100110000111100Появление во втором окне кода 101101000011000110110001001100001111006Ввод "абв", сжатие с деревом10110100011100010111000011110000011100Появление во втором окне кода 101101000111000101110000111100000111007Ввод "101", сжатие с деревом101000011000000110001101Появление во втором окне кода 1010000110000001100011018Ввод "abc101абв", сжатие с деревомПоявление во втором окне кода 111010011010001110100110100000110001100110000011000100110000111100000111000011110001000110001011010000111001111100101110Появление во втором окне кода 1110100110100011101001101000001100011001100000110001001100001111000001110000111100010001100010110100001110011111001011109Вставка текста "abc" из буфераТекст вставилсяТекст вставился10Вставка картинкиКартинка не вставляетсяКартинка не вставляется11Преобразование текста "abc" в код 11100, затем получение текста обратноПоявление в первом окне "abc"Появление в первом окне "abc"12Преобразование текста "abc" в код с деревом 10110100001100011011000100110000111100, затем получение текста обратноПоявление в первом окне "abc"Появление в первом окне "abc"13Открыть бинарный файл с текстом 10110100011abc100010111000011110000011100ОшибкаСообщение: Строка содержит символы, помимо 1 и 014Открыть бинарный файл с текстом 01ОшибкаСообщение: Невозможно прочитать код. Откройте корректный файл15Открыть файл с текстом "привет"Успешность операцииУспешность операции16Открыть файл с бинарным кодомУспешность операцииУспешность операции17Сохранение текста "привет"Успешность операцииУспешность операции18Сохранение кода 1010011100000111011111010 в файлУспешность операцииУспешность операции19Очистить поляУспешность операцииУспешность операцииТаблица 2. Черный ящик (Первая часть)
Проверяемая ситуация12345678910Тестирование ввода текста и преобразования его в кодВвод латинских букв и сжатие кода без дерева+         Ввод кириллицы и сжатие кода без дерева +        Ввод цифр и сжатие кода без дерева  +       Ввод кириллицы, цифр и латинских букв и сжатие кода без дерева   +      Ввод латинских букв и сжатие кода с деревом    +     Ввод кириллицы и сжатие кода с деревом     +    Ввод цифр и сжатие кода с деревом      +   Ввод кириллицы, цифр и латинских букв и сжатие кода с деревом       +  Вставка из буфера обмена текста        + Вставка из буфера обмена не текста         +Тестирование ввода кода и преобразование его в текстПреобразование кода после сжатия текста без дерева          Преобразование кода после сжатия текста с деревом          Открытие файла, содержащего не только нули и единицы          Открытие файла, содержащего нерасшифровываемый код          Тестирование функций программыТестирование преобразования текста в код++++      Тестирование преобразования текста с деревом в код    ++++  Тестирование получения текста из кода          Тестирование открытия текстового файла          Тестирование открытия бинарного файла          Тестирование сохранения текстового файла          Тестирование сохраниения бинарного файла          Тестирование очищения полей                Таблица 3. Черный ящик (Вторая часть)
Проверяемая ситуация111213141516171819Тестирование ввода текста и преобразования его в кодВвод латинских букв и сжатие кода без дерева         Ввод кириллицы и сжатие кода без дерева         Ввод цифр и сжатие кода без дерева         Ввод кириллицы, цифр и латинских букв и сжатие кода без дерева         Ввод латинских букв и сжатие кода с деревом         Ввод кириллицы и сжатие кода с деревом         Ввод цифр и сжатие кода с деревом         Ввод кириллицы, цифр и латинских букв и сжатие кода с деревом         Вставка из буфера обмена текста         Вставка из буфера обмена не текста         Тестирование ввода кода и преобразование его в текстПреобразование кода после сжатия текста без дерева+        Преобразование кода после сжатия текста с деревом +       Открытие файла, содержащего не только нули и единицы  +      Открытие файла, содержащего нерасшифровываемый код   +     Тестирование функций программыТестирование преобразования текста в код +       Тестирование преобразования текста с деревом в код  +      Тестирование получения текста из кода ++      Тестирование открытия текстового файла    +    Тестирование открытия бинарного файла     +   Тестирование сохранения текстового файла      +  Тестирование сохраниения бинарного файла       + Тестирование очищения полей        +     
     
     
     
     
     
     
     23
     
     
     
     
     
     
     
     
